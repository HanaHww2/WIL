
# Design Pattern
#### 개념
소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말하며, 주로 객체 지향 설계에 관한 것이다.

디자인 패턴은 **객체지향의 기본 특성과 객체 지향의 원칙**에 입각해서 우리에게 어떻게 객체지향 시스템을 잘 설계할 것인지 알려주는 설계 디자이너이자 컨설턴트라고 볼 수 있다.
즉, 좋은 코드를 헤메이지 않고 잘 작성하도록 도와주는 가이드와 같다.  
이러한 패턴은 경험을 통해 검증된 산물이므로, 우리는 이러한 선배 개발자들의 노고가 담긴 패턴을 활용해 좌충우돌하는 시간을 줄일 수 있을 것이다.

#### 핵심
패턴의 설계 구조를 보면 대부분 비슷한데, 이유는 객체 지향적인 설계로부터 문제를 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부분 두 가지 구조로 정리되기 때문이다.

- **클래스 상속**과 **오브젝트 합성**이다.

패턴에서 가장 중요한 것은 패턴의 핵심이 담긴 목적 또는 의도다.

- 패턴을 적용할 상황, 해결해야 할 문제, 솔루션의 구조와 각 요소의 역할과 함께 핵심 의도가 무엇인지를 기억해둬야 한다.
---

## 객체지향 특성

### 상속

### 추상화

### 캡슐화

### 다형성
---
## 객체 지향 설계 원칙(SOLID)
5가지 객체 지향 설계 원칙으로 로버트 마틴에 의해 정리되었다.

### SRP(The Single Responsibility Principle) : 단일 책임 원칙
> 하나의 클래스, 모듈 등은 하나의 책임을 가져야 한다는 원칙이다.
> 
### OCP(The Open Closed Principle) : 개방 폐쇄 원칙
> 확장에는 열려있고 수정(변화)에는 닫혀있다.

클래스의 내부 코드 변경이 없이, 기능을 확장하여 사용할 수 있어야 한다.
클래스를 인터페이스를 통해 확장에는 개방되도록 하고, 인터페이스를 이용하는 클래스 자신의 변화는 불필요하게 일어나지 않도록 폐쇄되어 있어야 한다.

클래스 간의 결합도를 최대한 줄여서 확장이 필요한 경우에 해당 기능을 담당하는 클래스들만 수정하고, 그 외 클래스들에는 부작용을 일으키는 영향을 만들지 않도록 설계하는 것이다.

#### 높은 응집도와 낮은 결합도

OCP를 높은 응집도와 낮은 결합도와 같은 고전적 소프트웨어 개발 원리로 설명할 수도 있다.

**높은 응집도**

응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다. 이는 클래스 레벨부터 패키지, 컴포넌트, 모듈에 이르기까지 대상의 크기가 달라져도 동일한 원리로 적용될 수 있다.

또한 응집도가 높은 것은 변화가 일어날 때, 변화의 대상에서는 변하는 부분이 크다는 것으로 설명할 수 있다. 여러 관심사가 아닌 하나의 관심사만 가지고 있기 때문에 변화가 일어날 하나의 책임이 그 모듈의 전체 책임이자 내용이기 때문이다. 

즉, 변경이 발생하면, 작업은 항상 대상에서 전체적으로 일어나고 무엇을 변경할지 명확하며, 그 것이 다른 부분(클래스 등)에 수정을 요구하지도 않고, 기능에 영향을 끼치지도 않는다. 검증이 필요하다면 "변경이 일어난 대상만"을 테스트하는 것으로도 손 쉽게 확인할 수 있다.

**낮은 결합도**

높은 응집도보다 더 민감한 원칙이다.
결합도는 '하나의 오브젝트가 변경될 때, 관계를 맺은 다른 오브젝트에 변화를 요구하는 정도'로 설명할 수 있다.

결합도가 낮아지면 변화에 대응하는 속도가 높아지고, 확장에 용이하다.

책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다.
느슨한 연결은 **관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공**하고, **나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것**이다.

### LSP(The Liskov Substitution Principle) : 리스코프 치환 원칙

1988년 바바라 리스코프가 올바른 상속 관계의 특징을 정의하기 위해 발표한 것으로, 하위 타입은 상위 타입을 대체할 수 있어야 한다는 것이다.
즉, 해당 객체를 사용하는 클라이언트는 상위 클래스 객체에 하위의 구체적 클래스가 할당되어도, 차이점을 인식하지 못한 채 상위 타입의 퍼블릭 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다는 것이다.

### ISP(The Interface Segregation Principle) : 인터페이스 분리 원칙

목적과 관심이 다른 클라이언트가 있다면 이를 적절히 분리해서 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공한다.

### DIP(The Dependency Inversion Principle) : 의존 관계 역전 원칙
> 구현체가 아닌 추상체에 의존한다는 원칙이다.  

어떤 객체가 특정 기능을 수행하기 위해서 다른 객체에 의존하게 될 때, 이 객체를 추상화 된 클래스에 의존하게 함으로써 해당 기능을 수행하기 위한 최소한의 정보에만 노출되도록 한다.

이를 통해서 실제 기능의 구현은 추상화, 캡슐화 되어서 클라이언트 객체 (특정 객체를 활용하는 객체를 클라이언트 객체라고 부른다.) 에게는 드러나지 않도록 할 수 있다.

의존 역전 원칙에서 의존성이 역전되는 시점은 컴파일 시점으로, 어떤 구현체를 클라이언트가 활용할지 정해지는 때라고 볼 수 있다.

참고 자료)
1. 헤드퍼스트 디자인패턴
2. 토비의 스프링
3. https://mangkyu.tistory.com/194 [MangKyu's Diary:티스토리]





