# Design Pattern
#### 개념
소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말하며, 주로 객체 지향 설계에 관한 것이다.

디자인 패턴은 **객체지향의 기본 특성과 객체 지향의 원칙**에 입각해서 우리에게 어떻게 객체지향 시스템을 잘 설계할 것인지 알려주는 설계 디자이너이자 컨설턴트라고 볼 수 있다.
즉, 좋은 코드를 헤메이지 않고 잘 작성하도록 도와주는 가이드와 같다.  
이러한 패턴은 경험을 통해 검증된 산물이므로, 우리는 이러한 선배 개발자들의 노고가 담긴 패턴을 활용해 좌충우돌하는 시간을 줄일 수 있을 것이다.

#### 핵심
패턴의 설계 구조를 보면 대부분 비슷한데, 이유는 객체 지향적인 설계로부터 문제를 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부분 두 가지 구조로 정리되기 때문이다.

- **클래스 상속**과 **오브젝트 합성**이다.

패턴에서 가장 중요한 것은 패턴의 핵심이 담긴 목적 또는 의도다.

- 패턴을 적용할 상황, 해결해야 할 문제, 솔루션의 구조와 각 요소의 역할과 함께 핵심 의도가 무엇인지를 기억해둬야 한다.
---

## 객체지향 특성

### 상속

### 추상화

### 캡슐화

### 다형성
---
## 객체 지향 설계 원칙(SOLID)
5가지 객체 지향 설계 원칙으로 로버트 마틴에 의해 정리되었다.

### SRP(The Single Responsibility Principle) : 단일 책임 원칙
- 하나의 클래스, 모듈 등은 하나의 책임을 가져야 한다는 원칙이다.
 
### OCP(The Open Closed Principle) : 개방 폐쇄 원칙
- 확장에는 열려있고 수정(변화)에는 닫혀있다.
  - 클래스의 내부 코드 변경이 없이, 기능을 확장하여 사용할 수 있어야 한다.
  - 클래스를 인터페이스를 통해 확장에는 개방되도록 하고, 인터페이스를 이용하는 클래스 자신의 변화는 불필요하게 일어나지 않도록 폐쇄되어 있어야 한다.
  - 클래스 간의 결합도를 최대한 줄여서 확장이 필요한 경우에 해당 기능을 담당하는 클래스들만 수정하고, 그 외 클래스들에는 부작용을 일으키는 영향을 만들지 않도록 설계하는 것이다.

#### 높은 응집도와 낮은 결합도
OCP를 높은 응집도와 낮은 결합도와 같은 고전적 소프트웨어 개발 원리로 설명할 수도 있다.

**높은 응집도**
- 응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.
  - 이는 클래스 레벨부터 패키지, 컴포넌트, 모듈에 이르기까지 대상의 크기가 달라져도 동일한 원리로 적용될 수 있다.

- 또한 응집도가 높은 것은 변화가 일어날 때, 변화의 대상에서는 변하는 부분이 크다는 것으로 설명할 수 있다.
  - 여러 관심사가 아닌 하나의 관심사만 가지고 있기 때문에 변화가 일어날 하나의 책임이 그 모듈의 전체 책임이자 내용이기 때문이다. 
  - 즉, 변경이 발생하면, 작업은 항상 대상에서 전체적으로 일어나고 무엇을 변경할지 명확하며, 그 것이 다른 부분(클래스 등)에 수정을 요구하지도 않고, 기능에 영향을 끼치지도 않는다. 검증이 필요하다면 "변경이 일어난 대상만"을 테스트하는 것으로도 손 쉽게 확인할 수 있다.

**낮은 결합도**
- 높은 응집도보다 더 민감한 원칙이다.
- 결합도는 '하나의 오브젝트가 변경될 때, 관계를 맺은 다른 오브젝트에 변화를 요구하는 정도'로 설명할 수 있다.
  - 결합도가 낮아지면 변화에 대응하는 속도가 높아지고, 확장에 용이하다.
- 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다.
  - 느슨한 연결은 **관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공**하고, **나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것**이다.

### LSP(The Liskov Substitution Principle) : 리스코프 치환 원칙
- 1988년 바바라 리스코프가 올바른 상속 관계의 특징을 정의하기 위해 발표한 것으로, 하위 타입은 상위 타입을 대체할 수 있어야 한다는 것이다.
  - 즉, 해당 객체를 사용하는 클라이언트는 상위 클래스 객체에 하위의 구체적 클래스가 할당되어도, 차이점을 인식하지 못한 채 상위 타입의 퍼블릭 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다는 것이다.

### ISP(The Interface Segregation Principle) : 인터페이스 분리 원칙

- 목적과 관심이 다른 클라이언트가 있다면 이를 적절히 분리해서 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공한다.

### DIP(The Dependency Inversion Principle) : 의존 관계 역전 원칙
- 구현체가 아닌 추상체에 의존한다는 원칙이다.  
  - 어떤 객체가 특정 기능을 수행하기 위해서 다른 객체에 의존하게 될 때, 이 객체를 추상화 된 클래스에 의존하게 함으로써 해당 기능을 수행하기 위한 최소한의 정보에만 노출되도록 한다.
  - 이를 통해서 실제 기능의 구현은 추상화, 캡슐화 되어서 클라이언트 객체 (특정 객체를 활용하는 객체를 클라이언트 객체라고 부른다.) 에게는 드러나지 않도록 할 수 있다.
  - 의존 역전 원칙에서 의존성이 역전되는 시점은 컴파일 시점으로, 어떤 구현체를 클라이언트가 활용할지 정해지는 때라고 볼 수 있다.

참고 자료)
1. 헤드퍼스트 디자인패턴
2. 토비의 스프링
3. https://mangkyu.tistory.com/194 [MangKyu's Diary:티스토리]
